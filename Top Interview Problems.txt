1. https://leetcode.com/problems/reverse-string/description/
	->	Write a function that reverses a string. The input string is given as an array of characters s.
	
	Two pointer approach from start one and from last another to keep swapping.

public class Solution {
    public void ReverseString(char[] s) {
        int length = s.Count();
        int i = 0;
        int j = length - 1;

        while (i<j)
        {
            //swap s[i] , s[j]
            char temp = s[i];
            s[i] = s[j];
            s[j] = temp;
            i++; j--;
        }

        for(int z=0; z<length; z++)
        {
            Console.WriteLine(s[z]);
        }
    }
}

2. https://leetcode.com/problems/fizz-buzz/description/	

 public class Solution {
    public IList<string> FizzBuzz(int n) {
           List<string> answer = new List<string>();
           for(int i=1;i<=n;i++)
           {
               if(i % 3 == 0 && i % 5 == 0)
               {
                  answer.Add("FizzBuzz");
                  continue;  
               }
               if(i%3 == 0)
               {
                  answer.Add("Fizz");
                  continue;  
               }
               if(i % 5 == 0)
               {
                  answer.Add("Buzz");
                  continue;  
               }
               answer.Add(i.ToString());
           }

           return answer;
    }
}

3. https://leetcode.com/problems/single-number/description/
	-> Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

		You must implement a solution with a linear runtime complexity and use only constant extra space.

	Eg: 
	----
		Input: nums = [2,2,1]
		Output: 1
				
		Input: nums = [4,1,2,1,2]
		Output: 4

Approach:
----------
	Bruteforce would take O(n^2)
	If we use HAshMap takes O(n) + space of O(n)
	But to have linear complexity, there is another approach suggested to use bitwise operators.
	Hints to note:
	-------------
		A xor A = 0; A xor 0 = A; 
	
	so in our case it is clearly mentioned about there will be only one single element, so using this approach to xoring all the 
elements, we will remain with last single element.
		Eg: [4,1,2,1,2] => 4 ^ 1 ^ 2 ^ 1 ^ 2 => 1^1 would become 0, 2^2 would become 0; remaining 4 will be returned as answer.
		
public class Solution {
    public int SingleNumber(int[] nums) {
        int ans = 0;
        foreach(int i in nums)
        {
            ans=ans^i;//bitwise operator xor
        } 
        return ans;
    }
}


4. https://leetcode.com/problems/maximum-depth-of-binary-tree/description/	
	-> Given the root of a binary tree, return its maximum depth.

		A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.
			Input: root = [3,9,20,null,null,15,7]
			Output: 3

Approach:
----------
	if root is null, return 0;
	else, tree height is 1 and we will calculate the max of left subtree height, right sub tree height.
	i.e, 1 + Math.Max(MaxDepth(root.left), MaxDepth(root.right))
	
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
public class Solution {
    public int MaxDepth(TreeNode root) {
        if(root == null) return 0;

        int result = 1 + Math.Max(MaxDepth(root.left),
                                  MaxDepth(root.right));
        return result;
    }
}

5. https://leetcode.com/problems/move-zeroes/description/
	-> Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.

		Note that you must do this in-place without making a copy of the array.	

Examples:
----------
		Input: nums = [0,1,0,3,12]
		Output: [1,3,12,0,0]
		
		Input: nums = [0]
		Output: [0]	
 	
Intuition:
-----------
	Loop through each element with two pointers i with 0, j with 1;
	we check if num[i] == 0 && num[j] != 0, then do swap i, j--
	else, move only j++ to check next 	
	
	